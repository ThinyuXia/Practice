##### 1.dfs

##### 1.1全排列

```java
public class Main{
    static final int N = 10;
    static int[] path = new int[N];
    static boolean[] s = new boolean[N];
    static int n;
    public static void dfs(int u){

        if(u == n){
            for(int i = 0;i < n;i++)
                System.out.print(path[i] + " ");
            System.out.println();
        }

        for(int i = 1;i <= n;i ++){
            if(! s[i]){
                path[u] = i;
                s[i] = true;
                dfs(u + 1);
                s[i] = false;
            }
        }
    }

    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        dfs(0);

    }
}
```

##### 时间复杂度：大约是O(n!)

##### 空间复杂度：O(n) n为全排列数的长度

##### 1.2八皇后问题

做法1:与全排列思路类似，先枚举每行中皇后的位置，再根据是否可以被攻击到进行剪枝

```java
import java.util.*;
public class Main{
    static char[][] grid = new char[10][10];
    static boolean[] col = new boolean[10];
    static boolean[] dg = new boolean[20];
    static boolean[] udg = new boolean[20];
    static int n;
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        n = in.nextInt();
        for(int i = 0;i < n;i ++) Arrays.fill(grid[i],'.');
        dfs(0);
    }
    
    public static void dfs(int u){
        if(u == n){
            for(int i = 0;i < n;i ++){
                for(int j = 0;j < n;j ++) System.out.print(grid[i][j]);
                System.out.println();
            }
            System.out.println();
            return;
        }
        for(int i = 0;i < n;i ++){
            if(! col[i] && ! dg[u + i] && ! udg[u - i + n]){
                grid[u][i] = 'Q';
                col[i] = dg[u + i] = udg[u - i + n] = true;
                dfs(u + 1);
                col[i] = dg[u + i] = udg[u - i + n] = false;
                grid[u][i] = '.';
            }
        }
    }
}

```



做法2:原始做法

 ```java
 public class Main{
     static int n;
     static boolean[] col = new boolean[10];
     static boolean[] row = new boolean[10];
     static boolean[] dg = new boolean[20];
     static boolean[] udg = new boolean[20];
     static char[][] g = new char[20][20];
     public static void main(String[] args){
         Scanner in = new Scanner(System.in);
         n = in.nextInt();
         dfs(0,0,0);
     }
     public static void dfs(int x,int y,int cnt){
         if(cnt > n) return;
         if (y == n) {
             y = 0; 
             x ++;
         }
         if(x == n){
             if(cnt == n){
                 for(int i = 0;i < n;i ++){
                     for(int j = 0;j < n;j ++)
                         System.out.print(g[i][j]);
                     System.out.println();
                 }
                 
                 System.out.println();
             }
             return;
         }
         
         g[x][y] = '.';
         dfs(x,y + 1,cnt); //不放皇后
         if (!row[x] && !col[y] && !dg[y - x + n] && !udg[x + y])
             {
                 row[x] = col[y] = dg[y - x + n] = udg[x + y] = true;
                 g[x][y] = 'Q';
                 dfs(x, y + 1, cnt + 1); //放皇后
                 g[x][y] = '.';
                 row[x] = col[y] = dg[y - x + n] = udg[x + y] = false;
             }
     }
 }
 ```

##### 时间复杂度：大约是O(2 ^ (n * n))
