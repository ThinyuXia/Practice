##### 1.01背包问题

特点：每个物品最多使用一次

![](https://s3.bmp.ovh/imgs/2022/05/18/0e125fb97a47fa35.png)



[原题链接](https://www.acwing.com/problem/content/2/)

##### 朴素版代码

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        final int N = 1010;
        int n = in.nextInt();
        int m = in.nextInt();
        int[] v = new int[N];
        int[] w = new int[N];
        int[][] f = new int[N][N];
        
        //f[0][0 ～ m] = 0,不用手动进行初始化
        
        for(int i = 1;i <= n;i ++){
            v[i] = in.nextInt();
            w[i] = in.nextInt();
        }
        
        for(int i = 1;i <= n;i ++){
            for(int j = 0;j <= m;j ++){
                f[i][j] = f[i - 1][j];
                if(j >= v[i]) f[i][j] = Math.max(f[i][j],f[i - 1][j - v[i]] + w[i]);
            }
        }
        System.out.println(f[n][m]);
    }
}
```



##### 优化版代码

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        final int N = 1010;
        int n = in.nextInt();
        int m = in.nextInt();
        int[] v = new int[N];
        int[] w = new int[N];
        int[] f = new int[N];
        
        //f[0][0 ～ m] = 0,不用手动进行初始化
        
        for(int i = 1;i <= n;i ++){
            v[i] = in.nextInt();
            w[i] = in.nextInt();
        }
        
        //1.删掉第一维的原因是每次计算第i层只会用到i - 1层
        //2.j如果正序计算会导致f[j - v[i]]是第i层的数据，状态被污染
        for(int i = 1;i <= n;i ++)
            for(int j = m;j >= v[i];j --)
                f[j] = Math.max(f[j],f[j - v[i]] + w[i]);
        System.out.println(f[m]);
    }
}
```



##### 2.完全背包问题

特点：每个物品可以使用无限次

![](https://s3.bmp.ovh/imgs/2022/05/19/f915ee3eb4b34933.png)



[原题链接](https://www.acwing.com/problem/content/description/3/)

##### 朴素版代码

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        final int N = 1010;
        int n = in.nextInt();
        int m = in.nextInt();
        int[] v = new int[N];
        int[] w = new int[N];
        int[][] f = new int[N][N];
        
        
        for(int i = 1;i <= n;i ++){
            v[i] = in.nextInt();
            w[i] = in.nextInt();
        }
        
        for(int i = 1;i <= n;i ++)
            for(int j = 0;j <= m;j ++)
             for(int k = 0;k * v[i] <= j;k ++)
                f[i][j] = Math.max(f[i][j],f[i - 1][j - k * v[i]] + k * w[i]);
                
        System.out.println(f[n][m]);
    
    }
    
}
```



##### 优化成2维代码



##### <img src="https://s1.ax1x.com/2022/05/19/ObElRA.md.png" style="zoom:150%;" />



```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        final int N = 1010;
        int n = in.nextInt();
        int m = in.nextInt();
        int[] v = new int[N];
        int[] w = new int[N];
        int[][] f = new int[N][N];
        
        
        for(int i = 1;i <= n;i ++){
            v[i] = in.nextInt();
            w[i] = in.nextInt();
        }
        
        for(int i = 1;i <= n;i ++)
            for(int j = 0;j <= m;j ++){
                f[i][j] = f[i - 1][j];
                if(j >= v[i]) f[i][j] = Math.max(f[i][j],f[i][j - v[i]] + w[i]);
            }
                
        System.out.println(f[n][m]);
    
    }
    
}
```



##### 优化成1维代码

![](https://s3.bmp.ovh/imgs/2022/05/19/6e7f7f2360c578d8.png)

```java
import java.util.*;
public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        final int N = 1010;
        int n = in.nextInt();
        int m = in.nextInt();
        int[] v = new int[N];
        int[] w = new int[N];
        int[] f = new int[N];
       
        for(int i = 1;i <= n;i ++){
            v[i] = in.nextInt();
            w[i] = in.nextInt();
        }
        for(int i = 1;i <= n;i ++)
            for(int j = v[i];j <= m;j ++){
                // f[i][j] = f[i - 1][j];
                f[j] = Math.max(f[j],f[j - v[i]] + w[i]);
            }
        System.out.println(f[m]);
    }
}
```

